# src/backend/imageService//app.ts
import express from 'express';
import imageRoutes from './src/routes/imageRoutes';
import dotenv from 'dotenv';

dotenv.config();

const port = process.env.PORT;
const app = express();
app.use(express.json());
app.use('/api', imageRoutes);
app.listen(port, () => 
    {
        console.log(`BFF service running on port ${port}`);
    });
    
export default app;


# src/backend/imageService//src/controllers/EmployeeControllers.ts
import { Request, Response } from 'express';
import { ImageProcessor } from '../middlewares/InitImageProcessor';
import { SetUserPathImage } from '../services/ImageServices';

export const initNewEmployee = async (req: Request, res: Response) => 
{
    const { email } = req.body;

    try
    {
        let pathCreated : string | undefined = await ImageProcessor.processUserImages(email);
        await SetUserPathImage(email, pathCreated)
        res.status(200).json({ message: "User successfully connected!" });
    }
    catch (error)
    {
        console.error('Error fetching data:', error);
        res.status(500).json({ error: 'Failed to fetch data' });
    }
};


# src/backend/imageService//src/controllers/ImageControllers.ts
import { Request, Response } from 'express';
import * as path from 'path';
import * as fs from 'fs';

export const GetAvatar = async (req: Request, res: Response) => 
{
    const { imagePath, level } = req.body;

    try
    {
        const absolutePath = path.resolve(imagePath + '/' + level);
        
        // Check if the file exists
        if (!fs.existsSync(absolutePath))
        {
            return res.status(404).json({ error: 'Image not found' });
        }

        // Send the image file as a response
        res.sendFile(absolutePath, (err: any) => 
        {
            if (err)
            {
                console.error('Error sending file:', err);
                res.status(500).send('Error sending image');
            }
        });
    }
    catch (error)
    {
        console.error('Error fetching data:', error);
        res.status(500).json({ error: 'Failed to fetch data' });
    }
};


# src/backend/imageService//src/middlewares/InitImageProcessor.ts
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import sharp from 'sharp';
import { fileURLToPath } from 'url';

// Obtenir le chemin du fichier actuel et du répertoire
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Chemin absolu pour le répertoire des images
const BASE_IMAGES_DIR = path.resolve('C:/Users/pierr/Desktop/epita/projet_ping/src/backend/imageService/images');

export class ImageProcessor
{
    private static inputDir = path.join(BASE_IMAGES_DIR, 'input');

    /**
     * Compresses an image using Sharp
     * @param inputPath - The path of the input image
     * @param outputPath - The path where the compressed image will be saved
     */
    static async compressImageSharp(inputPath: string, outputPath: string): Promise<void>
    {
        try
        {
            await sharp(inputPath)
                .resize(800)
                .toFormat('jpeg')
                .jpeg({ quality: 80 })
                .toFile(outputPath);
            console.log(`Image compressed and saved to ${outputPath}`);
        }
        catch (error)
        {
            console.error('Error compressing image with sharp:', error);
        }
    }

    /**
     * Processes all images in the input directory
     * @param outputDir - The directory where the processed images will be saved
     */
    static async processImages(outputDir: string): Promise<void>
    {
        if (!fs.existsSync(this.inputDir))
        {
            console.error(`Input directory does not exist: ${this.inputDir}`);
            return;
        }

        const files = fs.readdirSync(this.inputDir);
        for (const file of files)
        {
            const inputPath = path.join(this.inputDir, file);
            const outputPathSharp = path.join(outputDir, `sharp-${file}`);

            await this.compressImageSharp(inputPath, outputPathSharp);
        }
    }

    /**
     * Generates a SHA-256 hash from an email
     * @param email - The email of the user
     * @returns The hash as a hexadecimal string
     */
    static hashEmail(email: string): string
    {
        return crypto.createHash('sha256').update(email).digest('hex');
    }

    /**
     * Creates a folder in the images directory using the hashed email as the folder name
     * @param email - The email of the user
     */
    static async createUserImageFolder(email: string): Promise<void>
    {
        const imagesDir = BASE_IMAGES_DIR;
        const userFolder = path.join(imagesDir, this.hashEmail(email));

        // Check if the images directory exists, if not, create it
        if (!fs.existsSync(imagesDir))
        {
            fs.mkdirSync(imagesDir, { recursive: true });
        }

        // Check if the user folder exists, if not, create it
        if (!fs.existsSync(userFolder))
        {
            fs.mkdirSync(userFolder, { recursive: true });
            console.log(`Dossier créé: ${userFolder}`);
        }
        else
        {
            console.log(`Le dossier existe déjà: ${userFolder}`);
        }
    }

    /**
     * Creates user image folder and processes images
     * @param email - The email of the user
     */
    static async processUserImages(email: string): Promise<string | undefined>
    {
        try
        {
            const pathPictures = path.join(BASE_IMAGES_DIR, this.hashEmail(email));
            await this.createUserImageFolder(email);
            console.log('User folder created successfully.');
            await this.processImages(pathPictures);
            console.log('Image processing completed.');
            return pathPictures;
        }
        catch (err)
        {
            console.error('Error creating user folder or processing images:', err);
            return undefined;
        }
    }
}


# src/backend/imageService//src/middlewares/ValidateRequest.ts
import { Request, Response, NextFunction } from 'express';

export const validateRequestGetAvatar = (req: Request, res: Response, next: NextFunction) => 
{
    const { path, level} = req.body;
    if (!path || !level)
    {
        return res.status(400).json({ error: 'path and level is required to find images' });
    }
    next();
};
export const validateRequestInit = (req: Request, res: Response, next: NextFunction) => 
{
    const { email } = req.body;
    if (!email)
    {
        return res.status(400).json({ error: 'email is required to init a new employee' });
    }
    next();
};

# src/backend/imageService//src/routes/imageRoutes.ts
import { Router } from 'express';
import { initNewEmployee } from '../controllers/EmployeeControllers';
import { GetAvatar } from '../controllers/ImageControllers';
import { validateRequestGetAvatar, validateRequestInit } from '../middlewares/ValidateRequest';

const router = Router();

router.post('/get', validateRequestGetAvatar, GetAvatar);
router.post('/init', validateRequestInit, initNewEmployee);

export default router;


# src/backend/imageService//src/services/ImageServices.ts
import axios from 'axios';

interface PathInput 
{
    email: string;
    path: string | undefined;
}

export const SetUserPathImage = async (email: string, path: string | undefined) => 
{
    const loginInput: PathInput = { email, path};
    const response = await axios.post('http://database:3000/api/setimagepath', loginInput);
    return response.data;
};

